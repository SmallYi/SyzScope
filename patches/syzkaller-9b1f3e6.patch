diff --git a/courier/queue.go b/courier/queue.go
new file mode 100644
index 00000000..b060f598
--- /dev/null
+++ b/courier/queue.go
@@ -0,0 +1,69 @@
+package courier
+
+import (
+	"sync"
+
+	"github.com/google/syzkaller/pkg/rpctype"
+)
+
+const (
+	Mutating = 0
+	Commands = 1
+	S2E      = 2
+)
+
+type S2EArgs struct {
+	Prog    []byte
+	Pointer []byte
+}
+
+var MutateArgsQueue = make([]rpctype.ProgQueue, 0)
+
+var CommandsQueue = make([]string, 0)
+var S2EArgsQueue = make([]S2EArgs, 0)
+var Mutex = &sync.Mutex{}
+
+//Append testcase to a queue waits for mutating
+func AppendMutatingQueue(p, pocProg []byte, nOfCalls int) {
+	a := rpctype.ProgQueue{
+		Prog:     p,
+		NOfCalls: nOfCalls,
+		PocProg:  pocProg,
+	}
+	MutateArgsQueue = append(MutateArgsQueue, a)
+}
+
+func AppendCommandsQueue(p []byte) {
+	CommandsQueue = append(CommandsQueue, string(p))
+}
+
+func AppendS2EQueue(p S2EArgs) {
+	S2EArgsQueue = append(S2EArgsQueue, p)
+}
+
+func RetrieveFirstArg(flag int) interface{} {
+	switch flag {
+	case Mutating:
+		if len(MutateArgsQueue) == 0 {
+			break
+		}
+		p := MutateArgsQueue[0]
+		MutateArgsQueue = MutateArgsQueue[1:]
+		return p
+	case Commands:
+		if len(CommandsQueue) == 0 {
+			break
+		}
+		p := CommandsQueue[0]
+		CommandsQueue = CommandsQueue[1:]
+		return []byte(p)
+	case S2E:
+		if len(S2EArgsQueue) == 0 {
+			break
+		}
+		p := S2EArgsQueue[0]
+		S2EArgsQueue = S2EArgsQueue[1:]
+		return p
+	}
+	return nil
+}
diff --git a/courier/utilities.go b/courier/utilities.go
new file mode 100644
index 00000000..dd77605a
--- /dev/null
+++ b/courier/utilities.go
@@ -0,0 +1,68 @@
+package courier
+
+import (
+	"bytes"
+	"fmt"
+	"io"
+	"os"
+	"path"
+
+	"github.com/google/syzkaller/pkg/log"
+)
+
+var AnalyzerPath string
+var ConfirmedSuccess = false
+
+func AppendTestcase(testcase, pocProg []byte, nOfCalls int) {
+	AppendMutatingQueue(testcase, pocProg, nOfCalls)
+}
+
+func RemoveComments(text []byte) []byte {
+	var res []byte
+	start := 0
+	lines := bytes.SplitAfter(text, []byte("\n"))
+	for i, line := range lines {
+		if line[0] != '#' {
+			start = i
+			break
+		}
+	}
+	for i := start; i < len(lines); i++ {
+		res = append(res, lines[i]...)
+	}
+	return res
+}
+
+func checkDuplication(hash string, f *os.File) bool {
+	line := make([]byte, 8)
+	for {
+		n, err := f.Read(line)
+		if n == 0 && err == io.EOF {
+			break
+		}
+		if err != nil {
+			fmt.Printf("Fail to read: %v\n", err)
+			return true
+		}
+		if string(line[:len(line)-1]) == hash {
+			return true
+		}
+	}
+	return false
+}
+
+func SaveToFile(filename string) {
+	hash := path.Base(AnalyzerPath)
+	work := path.Dir(path.Dir(AnalyzerPath))
+	success := path.Join(work, filename)
+	f, err := os.OpenFile(success, os.O_APPEND|os.O_RDWR|os.O_CREATE, 0600)
+	if err != nil {
+		log.Logf(0, "Fail to open %s: %v", success, err)
+		return
+	}
+	defer f.Close()
+	if !checkDuplication(hash, f) {
+		log.Logf(0, "Write %s to %s", filename, success)
+		f.WriteString(hash + "\n")
+	}
+}
diff --git a/pkg/build/netbsd.go b/pkg/build/netbsd.go
index 6faaeb2b..d22012b7 100644
--- a/pkg/build/netbsd.go
+++ b/pkg/build/netbsd.go
@@ -146,7 +146,7 @@ func (ctx netbsd) copyKernelToDisk(targetArch, vmType, outputDir, kernel string)
 		return fmt.Errorf("error syncing the instance %v", err)
 	}
 	// Make sure that the command has executed properly.
-	rep := inst.MonitorExecution(outc, errc, reporter, vm.ExitNormal)
+	rep := inst.MonitorExecution(outc, errc, reporter, vm.ExitNormal, time.Now(), -1)
 	if rep != nil {
 		return fmt.Errorf("error executing sync: %v", rep.Title)
 	}
diff --git a/pkg/instance/instance.go b/pkg/instance/instance.go
index d8883857..c24816ce 100644
--- a/pkg/instance/instance.go
+++ b/pkg/instance/instance.go
@@ -322,7 +322,7 @@ func (inst *inst) testInstance() error {
 	if err != nil {
 		return fmt.Errorf("failed to run binary in VM: %v", err)
 	}
-	rep := inst.vm.MonitorExecution(outc, errc, inst.reporter, vm.ExitNormal)
+	rep := inst.vm.MonitorExecution(outc, errc, inst.reporter, vm.ExitNormal, time.Now(), -1)
 	if rep != nil {
 		if err := inst.reporter.Symbolize(rep); err != nil {
 			// TODO(dvyukov): send such errors to dashboard.
@@ -412,7 +412,7 @@ func (inst *inst) testProgram(command string, testTime time.Duration) error {
 		return fmt.Errorf("failed to run binary in VM: %v", err)
 	}
 	rep := inst.vm.MonitorExecution(outc, errc, inst.reporter,
-		vm.ExitTimeout|vm.ExitNormal|vm.ExitError)
+		vm.ExitTimeout|vm.ExitNormal|vm.ExitError, time.Now(), -1)
 	if rep == nil {
 		return nil
 	}
@@ -423,7 +423,7 @@ func (inst *inst) testProgram(command string, testTime time.Duration) error {
 }
 
 func FuzzerCmd(fuzzer, executor, name, OS, arch, fwdAddr, sandbox string, procs, verbosity int,
-	cover, debug, test, runtest bool) string {
+	cover, debug, test, runtest, poc bool) string {
 	osArg := ""
 	if targets.Get(OS, arch).HostFuzzer {
 		// Only these OSes need the flag, because the rest assume host OS.
@@ -440,13 +440,13 @@ func FuzzerCmd(fuzzer, executor, name, OS, arch, fwdAddr, sandbox string, procs,
 		verbosityArg = fmt.Sprintf(" -vv=%v", verbosity)
 	}
 	return fmt.Sprintf("%v -executor=%v -name=%v -arch=%v%v -manager=%v -sandbox=%v"+
-		" -procs=%v -cover=%v -debug=%v -test=%v%v%v",
+		" -procs=%v -cover=%v -debug=%v -test=%v%v%v -poc=%v",
 		fuzzer, executor, name, arch, osArg, fwdAddr, sandbox,
-		procs, cover, debug, test, runtestArg, verbosityArg)
+		procs, cover, debug, test, runtestArg, verbosityArg, poc)
 }
 
 func OldFuzzerCmd(fuzzer, executor, name, OS, arch, fwdAddr, sandbox string, procs int, cover, test bool) string {
-	return FuzzerCmd(fuzzer, executor, name, OS, arch, fwdAddr, sandbox, procs, 0, cover, false, test, false)
+	return FuzzerCmd(fuzzer, executor, name, OS, arch, fwdAddr, sandbox, procs, 0, cover, false, test, false, false)
 }
 
 func ExecprogCmd(execprog, executor, OS, arch, sandbox string, repeat, threaded, collide bool,
diff --git a/pkg/mgrconfig/config.go b/pkg/mgrconfig/config.go
index 69df2a80..c7f071e1 100644
--- a/pkg/mgrconfig/config.go
+++ b/pkg/mgrconfig/config.go
@@ -114,4 +114,7 @@ type Config struct {
 	SyzFuzzerBin   string `json:"-"`
 	SyzExecprogBin string `json:"-"`
 	SyzExecutorBin string `json:"-"`
+	Testcase       string `json:"testcase"`
+	AnalyzerDir    string `json:"analyzer_dir"`
+	TimeLimit      string `json:"time_limit"`
 }
diff --git a/pkg/mgrconfig/load.go b/pkg/mgrconfig/load.go
index 4e413636..9ad59ac9 100644
--- a/pkg/mgrconfig/load.go
+++ b/pkg/mgrconfig/load.go
@@ -11,6 +11,7 @@ import (
 	"strings"
 
 	"github.com/google/syzkaller/pkg/config"
+	"github.com/google/syzkaller/pkg/log"
 	"github.com/google/syzkaller/pkg/osutil"
 	"github.com/google/syzkaller/prog"
 	_ "github.com/google/syzkaller/sys" // most mgrconfig users want targets too
@@ -208,7 +209,7 @@ func ParseEnabledSyscalls(target *prog.Target, enabled, disabled []string) ([]in
 				}
 			}
 			if n == 0 {
-				return nil, fmt.Errorf("unknown enabled syscall: %v", c)
+				log.Logf(0, "unknown enabled syscall: %v", c)
 			}
 		}
 	} else {
@@ -225,7 +226,7 @@ func ParseEnabledSyscalls(target *prog.Target, enabled, disabled []string) ([]in
 			}
 		}
 		if n == 0 {
-			return nil, fmt.Errorf("unknown disabled syscall: %v", c)
+			log.Logf(0, "unknown disabled syscall: %v", c)
 		}
 	}
 	if len(syscalls) == 0 {
diff --git a/pkg/report/linux.go b/pkg/report/linux.go
index 0657c4a1..cfc2221b 100644
--- a/pkg/report/linux.go
+++ b/pkg/report/linux.go
@@ -14,6 +14,9 @@ import (
 	"strings"
 	"time"
 
+	"github.com/google/syzkaller/courier"
+
+	"github.com/google/syzkaller/pkg/log"
 	"github.com/google/syzkaller/pkg/osutil"
 	"github.com/google/syzkaller/pkg/symbolizer"
 )
@@ -128,7 +131,7 @@ func (ctx *linux) ContainsCrash(output []byte) bool {
 }
 
 func (ctx *linux) Parse(output []byte) *Report {
-	oops, startPos, context := ctx.findFirstOops(output)
+	oops, startPos, context := ctx.findCriticalOops(output)
 	if oops == nil {
 		return nil
 	}
@@ -195,6 +198,109 @@ func (ctx *linux) findFirstOops(output []byte) (oops *oops, startPos int, contex
 	return
 }
 
+func (ctx *linux) findCriticalOops(output []byte) (oops *oops, startPos int, context string) {
+	kasanRegx := regexp.MustCompile(`BUG: KASAN: ([a-z\\-]+) in ([a-zA-Z0-9_]+).*`)
+	freeRegx := regexp.MustCompile(`BUG: KASAN: double-free or invalid-free in ([a-zA-Z0-9_]+).*`)
+	oobReadRegx := regexp.MustCompile(`\?!\?MAGIC\?!\?read->(\w*) size->(\d*)`)
+	var rAddr []uint64
+	var rSize []uint64
+	for pos, next := 0, 0; pos < len(output); pos = next + 1 {
+		next = bytes.IndexByte(output[pos:], '\n')
+		if next != -1 {
+			next += pos
+		} else {
+			next = len(output)
+		}
+		line := output[pos:next]
+		m := oobReadRegx.FindSubmatch(line)
+		if len(m) == 3 {
+			addr, err1 := strconv.ParseUint(string(m[1]), 16, 64)
+			size, err2 := strconv.ParseUint(string(m[2]), 10, 64)
+			if err1 == nil && err2 == nil {
+				rAddr = append(rAddr, addr)
+				rSize = append(rSize, size)
+			} else {
+				log.Logf(0, "Fail to convert string to (u)int: %v %v", err1, err2)
+			}
+		}
+		for _, oops1 := range linuxOopses {
+			if matchOops(line, oops1, ctx.ignores) {
+				line1 := ctx.takeAfterContext(line)
+				line2 := make([]byte, len(line1))
+				for _, e := range line1 {
+					if (e >= 0x20 && e <= 0x7e) || e == 0xa {
+						line2 = append(line2, e)
+					}
+				}
+				log.Logf(1, "line: %s", line2)
+				m := kasanRegx.Find(line2)
+				if m == nil {
+					m = freeRegx.Find(line2)
+				}
+				if m != nil {
+					log.Logf(1, "Match: [%s]", m)
+					oobWriteRegx := regexp.MustCompile(`Write of size (\d+) at addr (\w*)`)
+					wAddrs := oobWriteRegx.FindAllSubmatch(output[next:], -1)
+					for _, wAddr := range wAddrs {
+						if len(wAddr) > 0 {
+							addr2, err1 := strconv.ParseUint(string(wAddr[2]), 16, 64)
+							if err1 != nil {
+								log.Logf(0, "Fail to convert write address to uint64: %v", err1)
+								continue
+							}
+							size, err2 := strconv.ParseUint(string(wAddr[1]), 10, 64)
+							if err2 != nil {
+								log.Logf(0, "Fail to convert write size to uint64: %v", err2)
+								continue
+							}
+
+							for i, _ := range rAddr {
+								if (rAddr[i]+rSize[i] >= addr2 && rAddr[i] <= addr2) ||
+									(addr2+size >= rAddr[i] && addr2+size <= rAddr[i]+rSize[i]) ||
+									(addr2 <= rAddr[i] && addr2+size >= rAddr[i]+rSize[i]) {
+									courier.ConfirmedSuccess = true
+									break
+								}
+							}
+						}
+						if courier.ConfirmedSuccess {
+							break
+						}
+					}
+					oops = oops1
+					startPos = pos
+					context = ctx.extractContext(line)
+					return
+				}
+				oops = oops1
+				startPos = pos
+				context = ctx.extractContext(line)
+				break
+			}
+		}
+	}
+	return
+}
+
+func (ctx *linux) takeAfterContext(line []byte) []byte {
+	prefix := ctx.extractContext(line)
+	index := strings.Index(string(line), prefix)
+	new := make([]byte, len(line)-(index+len(prefix))+1)
+	copy(new, line[index+len(prefix):])
+	return new
+}
+
+func (ctx *linux) getNextLine(start int, output []byte) []byte {
+	next := bytes.IndexByte(output[start:], '\n')
+	if next != -1 {
+		next += start
+	} else {
+		next = len(output)
+	}
+	line := output[start:next]
+	return line
+}
+
 // Yes, it is complex, but all state and logic are tightly coupled. It's unclear how to simplify it.
 // nolint: gocyclo
 func (ctx *linux) findReport(output []byte, oops *oops, startPos int, context string, useQuestionable bool) (
diff --git a/pkg/repro/repro.go b/pkg/repro/repro.go
index 9c05f34b..3d2884ee 100644
--- a/pkg/repro/repro.go
+++ b/pkg/repro/repro.go
@@ -621,7 +621,7 @@ func (ctx *context) testImpl(inst *vm.Instance, command string, duration time.Du
 		return false, fmt.Errorf("failed to run command in VM: %v", err)
 	}
 	rep := inst.MonitorExecution(outc, errc, ctx.reporter,
-		vm.ExitTimeout|vm.ExitNormal|vm.ExitError)
+		vm.ExitTimeout|vm.ExitNormal|vm.ExitError, time.Now(), -1)
 	if rep == nil {
 		ctx.reproLog(2, "program did not crash")
 		return false, nil
diff --git a/pkg/rpctype/rpctype.go b/pkg/rpctype/rpctype.go
index fcc01a99..19abe3a5 100644
--- a/pkg/rpctype/rpctype.go
+++ b/pkg/rpctype/rpctype.go
@@ -128,3 +128,27 @@ type RunTestDoneArgs struct {
 	Info   []*ipc.ProgInfo
 	Error  string
 }
+
+type ProgQueue struct {
+	Length   int
+	Prog     []byte
+	NOfCalls int
+	PocProg  []byte
+}
+
+type GetQueueLenArgs struct {
+	Flag int
+}
+
+type GetQueueLenRes struct {
+	Length int
+}
+
+type FuzzerSignal struct {
+	Signal string
+}
+
+type GetCallsFromFuzzerArgs struct {
+	EnabledCalls map[string][]int
+	Sandbox      string
+}
diff --git a/prog/minimization.go b/prog/minimization.go
index 93a98655..6641b34c 100644
--- a/prog/minimization.go
+++ b/prog/minimization.go
@@ -29,7 +29,7 @@ func Minimize(p0 *Prog, callIndex0 int, crash bool, pred0 func(*Prog, int) bool)
 	p0, callIndex0 = removeCalls(p0, callIndex0, crash, pred)
 
 	// Try to minimize individual args.
-	for i := 0; i < len(p0.Calls); i++ {
+	for i := NOfCalls; i < len(p0.Calls); i++ {
 		ctx := &minimizeArgsCtx{
 			target:     p0.Target,
 			p0:         &p0,
@@ -58,7 +58,7 @@ func Minimize(p0 *Prog, callIndex0 int, crash bool, pred0 func(*Prog, int) bool)
 }
 
 func removeCalls(p0 *Prog, callIndex0 int, crash bool, pred func(*Prog, int) bool) (*Prog, int) {
-	for i := len(p0.Calls) - 1; i >= 0; i-- {
+	for i := len(p0.Calls) - 1; i >= NOfCalls; i-- {
 		if i == callIndex0 {
 			continue
 		}
diff --git a/prog/mutation.go b/prog/mutation.go
index 7203a86e..8248ab3e 100644
--- a/prog/mutation.go
+++ b/prog/mutation.go
@@ -34,19 +34,24 @@ func (p *Prog) Mutate(rs rand.Source, ncalls int, ct *ChoiceTable, corpus []*Pro
 		corpus: corpus,
 	}
 	for stop, ok := false, false; !stop; stop = ok && len(p.Calls) != 0 && r.oneOf(3) {
+		if len(p.Calls) == NOfCalls {
+			ctx.insertCallAtEnd()
+		}
 		switch {
 		case r.oneOf(5):
 			// Not all calls have anything squashable,
 			// so this has lower priority in reality.
-			ok = ctx.squashAny()
+			ok = ctx.squashAnyCus()
 		case r.nOutOf(1, 100):
-			ok = ctx.splice()
+			ok = ctx.spliceCus()
 		case r.nOutOf(20, 31):
-			ok = ctx.insertCall()
+			ok = ctx.insertCallCus()
 		case r.nOutOf(10, 11):
-			ok = ctx.mutateArg()
+			ok = ctx.mutateArgCus()
 		default:
-			ok = ctx.removeCall()
+			if len(p.Calls) > NOfCalls {
+				ok = ctx.removeCallCus()
+			}
 		}
 	}
 	p.sanitizeFix()
diff --git a/prog/mutation_custom.go b/prog/mutation_custom.go
new file mode 100644
index 00000000..66cba158
--- /dev/null
+++ b/prog/mutation_custom.go
@@ -0,0 +1,238 @@
+package prog
+
+import (
+	"fmt"
+	"strings"
+)
+
+var NOfCalls = 0
+var PocProg string
+var ExecutePoCOnly = true
+
+func (ctx *mutator) spliceCus() bool {
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return ctx.splice()
+	}
+	if len(ctx.corpus) == 0 || len(p.Calls)-NOfCalls <= 0 || len(p.Calls) >= ctx.ncalls {
+		return false
+	}
+	p0 := ctx.corpus[r.Intn(len(ctx.corpus))]
+	p0c := p0.Clone()
+	idx := r.Intn(len(p.Calls)-NOfCalls) + NOfCalls
+	p.Calls = append(p.Calls[:idx], append(p0c.Calls, p.Calls[idx:]...)...)
+	for i := len(p.Calls) - 1; i >= ctx.ncalls; i-- {
+		p.removeCall(i)
+	}
+	return true
+}
+
+// Picks a random complex pointer and squashes its arguments into an ANY.
+// Subsequently, if the ANY contains blobs, mutates a random blob.
+func (ctx *mutator) squashAnyCus() bool {
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return ctx.squashAny()
+	}
+	complexPtrs := p.complexPtrsCus()
+	if len(complexPtrs) == 0 {
+		return false
+	}
+	ptr := complexPtrs[r.Intn(len(complexPtrs))]
+	if !p.Target.isAnyPtr(ptr.Type()) {
+		p.Target.squashPtr(ptr, true)
+	}
+	var blobs []*DataArg
+	var bases []*PointerArg
+	ForeachSubArg(ptr, func(arg Arg, ctx *ArgCtx) {
+		if data, ok := arg.(*DataArg); ok && arg.Type().Dir() != DirOut {
+			blobs = append(blobs, data)
+			bases = append(bases, ctx.Base)
+		}
+	})
+	if len(blobs) == 0 {
+		return false
+	}
+	// TODO(dvyukov): we probably want special mutation for ANY.
+	// E.g. merging adjacent ANYBLOBs (we don't create them,
+	// but they can appear in future); or replacing ANYRES
+	// with a blob (and merging it with adjacent blobs).
+	idx := r.Intn(len(blobs))
+	arg := blobs[idx]
+	base := bases[idx]
+	baseSize := base.Res.Size()
+	arg.data = mutateData(r, arg.Data(), 0, maxBlobLen)
+	// Update base pointer if size has increased.
+	if baseSize < base.Res.Size() {
+		s := analyze(ctx.ct, ctx.corpus, p, p.Calls[0])
+		newArg := r.allocAddr(s, base.Type(), base.Res.Size(), base.Res)
+		*base = *newArg
+	}
+	return true
+}
+
+func (ctx *mutator) insertCallAtEnd() bool {
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return true
+	}
+	if len(p.Calls) >= ctx.ncalls {
+		return false
+	}
+	idx := len(p.Calls)
+	var c *Call
+	if idx < len(p.Calls) {
+		c = p.Calls[idx]
+	}
+	s := analyze(ctx.ct, ctx.corpus, p, c)
+	calls := r.generateCall(s, p, idx)
+	p.insertBefore(c, calls)
+	for len(p.Calls) > ctx.ncalls {
+		p.removeCall(idx)
+	}
+	return true
+}
+
+func (ctx *mutator) insertCallCus() bool {
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return ctx.insertCall()
+	}
+	if len(p.Calls) >= ctx.ncalls {
+		return false
+	}
+	idx := r.biasedRand(len(p.Calls)+1-NOfCalls, 5) + NOfCalls
+	if NOfCalls == len(p.Calls) {
+		idx = len(p.Calls)
+	}
+	var c *Call
+	if idx < len(p.Calls) {
+		c = p.Calls[idx]
+	}
+	s := analyze(ctx.ct, ctx.corpus, p, c)
+	calls := r.generateCall(s, p, idx)
+	p.insertBefore(c, calls)
+	for len(p.Calls) > ctx.ncalls {
+		p.removeCall(idx)
+	}
+	return true
+}
+
+// Removes a random call from program.
+func (ctx *mutator) removeCallCus() bool {
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return ctx.removeCall()
+	}
+	if len(p.Calls) == 0 {
+		return false
+	}
+	idx := r.Intn(len(p.Calls)-NOfCalls) + NOfCalls
+	p.removeCall(idx)
+	return true
+}
+
+// Mutate an argument of a random call.
+func (ctx *mutator) mutateArgCus() bool {
+	start := NOfCalls
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return ctx.mutateArg()
+	}
+	if len(p.Calls) == 0 {
+		return false
+	}
+	idx := chooseCallCus(p, r, start)
+	if idx < 0 {
+		return false
+	}
+	c := p.Calls[idx]
+	updateSizes := true
+	for stop, ok := false, false; !stop; stop = ok && r.oneOf(3) {
+		ok = true
+		ma := &mutationArgs{target: p.Target}
+		ForeachArg(c, ma.collectArg)
+		if len(ma.args) == 0 {
+			return false
+		}
+		s := analyze(ctx.ct, ctx.corpus, p, c)
+		chosenIdx := randomChoice(ma.priorities, r)
+		arg, argCtx := ma.args[chosenIdx], ma.ctxes[chosenIdx]
+		calls, ok1 := p.Target.mutateArg(r, s, arg, argCtx, &updateSizes)
+		if !ok1 {
+			ok = false
+			continue
+		}
+		p.insertBefore(c, calls)
+		idx += len(calls)
+		for len(p.Calls) > ctx.ncalls {
+			idx--
+			p.removeCall(idx)
+		}
+		if idx < 0 || idx >= len(p.Calls) || p.Calls[idx] != c {
+			panic(fmt.Sprintf("wrong call index: idx=%v calls=%v p.Calls=%v ncalls=%v",
+				idx, len(calls), len(p.Calls), ctx.ncalls))
+		}
+		if updateSizes {
+			p.Target.assignSizesCall(c)
+		}
+	}
+	return true
+}
+
+// Select a call based on the complexity of the arguments.
+func chooseCallCus(p *Prog, r *randGen, start int) int {
+	var callPriorities []float64
+	noArgs := true
+
+	for i, c := range p.Calls {
+		if i < start {
+			continue
+		}
+		totalPrio := float64(0)
+		ForeachArg(c, func(arg Arg, ctx *ArgCtx) {
+			prio, stopRecursion := arg.Type().getMutationPrio(p.Target, arg, false)
+			totalPrio += prio
+			ctx.Stop = stopRecursion
+		})
+		callPriorities = append(callPriorities, totalPrio)
+		if len(c.Args) > 0 {
+			noArgs = false
+		}
+	}
+
+	// Calls without arguments.
+	if noArgs {
+		return -1
+	}
+	return start + randomChoice(callPriorities, r)
+}
+
+func (p *Prog) complexPtrsCus() (res []*PointerArg) {
+	for i, c := range p.Calls {
+		if i < NOfCalls {
+			continue
+		}
+		ForeachArg(c, func(arg Arg, ctx *ArgCtx) {
+			if ptrArg, ok := arg.(*PointerArg); ok && p.Target.isComplexPtr(ptrArg) {
+				res = append(res, ptrArg)
+				ctx.Stop = true
+			}
+		})
+	}
+	return
+}
+
+func containPoC(prog []byte) bool {
+	if !ExecutePoCOnly {
+		return false
+	}
+	sProg := string(prog)
+	if len(sProg) < len(PocProg) {
+		return false
+	}
+	if strings.Compare(PocProg, sProg[:len(PocProg)]) == 0 {
+		return true
+	}
+	return false
+}
diff --git a/prog/rand.go b/prog/rand.go
index b350e31c..133f5a3a 100644
--- a/prog/rand.go
+++ b/prog/rand.go
@@ -14,6 +14,7 @@ import (
 
 	"github.com/google/syzkaller/pkg/ifuzz"
 	_ "github.com/google/syzkaller/pkg/ifuzz/generated" // pull in generated instruction descriptions
+	"github.com/google/syzkaller/pkg/log"
 )
 
 const (
@@ -692,7 +693,13 @@ func (a *ResourceType) generate(r *randGen, s *state) (arg Arg, calls []*Call) {
 			return
 		}
 	}
+	// Using previouse generated fd makes more sense for triggering PoC
+	arg = r.existingResource(s, a)
+	if arg != nil {
+		return
+	}
 	special := a.SpecialValues()
+	log.Logf(1, "No existingResource found, using SpecialValues: %x", special)
 	arg = MakeResultArg(a, nil, special[r.Intn(len(special))])
 	return
 }
diff --git a/syz-fuzzer/fuzzer.go b/syz-fuzzer/fuzzer.go
index b6e8be4b..06a1c52f 100644
--- a/syz-fuzzer/fuzzer.go
+++ b/syz-fuzzer/fuzzer.go
@@ -102,6 +102,8 @@ const (
 	OutputFile
 )
 
+var lastEnqueue time.Time
+
 func main() {
 	debug.SetGCPercent(50)
 
@@ -115,6 +117,7 @@ func main() {
 		flagPprof   = flag.String("pprof", "", "address to serve pprof profiles")
 		flagTest    = flag.Bool("test", false, "enable image testing mode")      // used by syz-ci
 		flagRunTest = flag.Bool("runtest", false, "enable program testing mode") // used by pkg/runtest
+		flagPoC     = flag.Bool("poc", false, "mutate base on current PoC")
 	)
 	flag.Parse()
 	outputType := parseOutputType(*flagOutput)
@@ -247,9 +250,9 @@ func main() {
 	for _, id := range r.CheckResult.EnabledCalls[sandbox] {
 		calls[target.Syscalls[id]] = true
 	}
+	fuzzer.sendCallsToManager(r.CheckResult.EnabledCalls, sandbox)
 	prios := target.CalculatePriorities(fuzzer.corpus)
 	fuzzer.choiceTable = target.BuildChoiceTable(prios, calls)
-
 	for pid := 0; pid < *flagProcs; pid++ {
 		proc, err := newProc(fuzzer, pid)
 		if err != nil {
@@ -259,7 +262,14 @@ func main() {
 		go proc.loop()
 	}
 
-	fuzzer.pollLoop()
+	MutatingLoop, err1 := newProc(fuzzer, *flagProcs)
+	if err1 != nil {
+		log.Fatalf("failed to create proc: %v", err)
+	}
+	fuzzer.procs = append(fuzzer.procs, MutatingLoop)
+	go MutatingLoop.checkMutatingQueueLoop()
+
+	fuzzer.pollLoop(*flagPoC)
 }
 
 // Returns gateCallback for leak checking if enabled.
@@ -310,11 +320,12 @@ func (fuzzer *Fuzzer) blacklistDataRaceFrames(frames []string) {
 	log.Logf(0, "%s", output)
 }
 
-func (fuzzer *Fuzzer) pollLoop() {
+func (fuzzer *Fuzzer) pollLoop(flagPoC bool) {
 	var execTotal uint64
 	var lastPoll time.Time
 	var lastPrint time.Time
 	ticker := time.NewTicker(3 * time.Second).C
+	lastEnqueue = time.Now()
 	for {
 		poll := false
 		select {
@@ -327,6 +338,11 @@ func (fuzzer *Fuzzer) pollLoop() {
 			log.Logf(0, "alive, executed %v", execTotal)
 			lastPrint = time.Now()
 		}
+		if !flagPoC && time.Since(lastEnqueue) > 4*time.Minute && time.Since(lastEnqueue) < 5*time.Minute && prog.ExecutePoCOnly {
+			log.Logf(0, "set fuzzer free")
+			fuzzer.sendSignal("set fuzzer free")
+			prog.ExecutePoCOnly = false
+		}
 		if poll || time.Since(lastPoll) > 10*time.Second {
 			needCandidates := fuzzer.workQueue.wantCandidates()
 			if poll && !needCandidates {
@@ -367,8 +383,10 @@ func (fuzzer *Fuzzer) poll(needCandidates bool, stats map[string]uint64) bool {
 	for _, inp := range r.NewInputs {
 		fuzzer.addInputFromAnotherFuzzer(inp)
 	}
-	for _, candidate := range r.Candidates {
-		fuzzer.addCandidateInput(candidate)
+	if !prog.ExecutePoCOnly {
+		for _, candidate := range r.Candidates {
+			fuzzer.addCandidateInput(candidate)
+		}
 	}
 	if needCandidates && len(r.Candidates) == 0 && atomic.LoadUint32(&fuzzer.triagedCandidates) == 0 {
 		atomic.StoreUint32(&fuzzer.triagedCandidates, 1)
@@ -541,3 +559,23 @@ func parseOutputType(str string) OutputType {
 		return OutputNone
 	}
 }
+
+func (fuzzer *Fuzzer) sendSignal(sg string) {
+	a := &rpctype.FuzzerSignal{
+		Signal: sg,
+	}
+	r := &rpctype.FuzzerSignal{}
+	if err := fuzzer.manager.Call("Manager.EmitSignal", a, r); err != nil {
+		log.Fatalf("emitSignal: failed to connect to manager: %v ", err)
+	}
+}
+
+func (fuzzer *Fuzzer) sendCallsToManager(enabledCalls map[string][]int, sandbox string) {
+	a := &rpctype.GetCallsFromFuzzerArgs{
+		EnabledCalls: enabledCalls,
+		Sandbox:      sandbox,
+	}
+	if err := fuzzer.manager.Call("Manager.GetCallsFromFuzzer", a, nil); err != nil {
+		log.Fatalf("Manager.GetCallsFromFuzzer call failed: %v", err)
+	}
+}
diff --git a/syz-fuzzer/proc.go b/syz-fuzzer/proc.go
index d815a58b..423cdd2f 100644
--- a/syz-fuzzer/proc.go
+++ b/syz-fuzzer/proc.go
@@ -9,10 +9,12 @@ import (
 	"math/rand"
 	"os"
 	"runtime/debug"
+	"strings"
 	"sync/atomic"
 	"syscall"
 	"time"
 
+	"github.com/google/syzkaller/courier"
 	"github.com/google/syzkaller/pkg/cover"
 	"github.com/google/syzkaller/pkg/hash"
 	"github.com/google/syzkaller/pkg/ipc"
@@ -76,12 +78,17 @@ func (proc *Proc) loop() {
 				proc.execute(proc.execOpts, item.p, item.flags, StatCandidate)
 			case *WorkSmash:
 				proc.smashInput(item)
+			case *WorkGrow:
+				proc.growInput(proc.execOpts, item, StatCandidate)
 			default:
 				log.Fatalf("unknown work type: %#v", item)
 			}
 			continue
 		}
 
+		if prog.ExecutePoCOnly {
+			continue
+		}
 		ct := proc.fuzzer.choiceTable
 		fuzzerSnapshot := proc.fuzzer.snapshot()
 		if len(fuzzerSnapshot.corpus) == 0 || i%generatePeriod == 0 {
@@ -177,6 +184,18 @@ func (proc *Proc) triageInput(item *WorkTriage) {
 	}
 }
 
+func (proc *Proc) growInput(execOpts *ipc.ExecOpts, item *WorkGrow, stat Stat) {
+	log.Logf(1, "#%v: growInput type=%x", proc.pid, item.flags)
+
+	proc.executeRaw(execOpts, item.p, stat)
+	fuzzerSnapshot := proc.fuzzer.snapshot()
+	for i := 0; i < 100; i++ {
+		p := item.p.Clone()
+		p.Mutate(proc.rnd, prog.RecommendedCalls, proc.fuzzer.choiceTable, fuzzerSnapshot.corpus)
+		proc.execute(proc.execOpts, p, ProgNormal, StatSmash)
+	}
+}
+
 func reexecutionSuccess(info *ipc.ProgInfo, oldInfo *ipc.CallInfo, call int) bool {
 	if info == nil || len(info.Calls) == 0 {
 		return false
@@ -250,7 +269,10 @@ func (proc *Proc) executeHintSeed(p *prog.Prog, call int) {
 func (proc *Proc) execute(execOpts *ipc.ExecOpts, p *prog.Prog, flags ProgTypes, stat Stat) *ipc.ProgInfo {
 	info := proc.executeRaw(execOpts, p, stat)
 	calls, extra := proc.fuzzer.checkNewSignal(p, info)
-	for _, callIndex := range calls {
+	for i, callIndex := range calls {
+		if i < prog.NOfCalls {
+			continue
+		}
 		proc.enqueueCallTriage(p, flags, callIndex, info.Calls[callIndex])
 	}
 	if extra {
@@ -343,3 +365,41 @@ func (proc *Proc) logProgram(opts *ipc.ExecOpts, p *prog.Prog) {
 		log.Fatalf("unknown output type: %v", proc.fuzzer.outputType)
 	}
 }
+
+func (proc *Proc) checkMutatingQueueLoop() {
+	for {
+		a := &rpctype.GetQueueLenArgs{
+			Flag: courier.Mutating,
+		}
+		r := &rpctype.GetQueueLenRes{}
+		if err := proc.fuzzer.manager.Call("Manager.GetQueueLen", a, r); err != nil {
+			log.Fatalf("checkArgsQueueLoop: failed to connect to manager: %v ", err)
+		}
+		if r.Length > 0 {
+			pq := &rpctype.ProgQueue{}
+			if err := proc.fuzzer.manager.Call("Manager.RetrieveArgsQueue", pq, pq); err != nil {
+				log.Fatalf("failed to connect to manager: %v ", err)
+			}
+			log.Logf(1, "New Arg Aviable: %s\n", pq.Prog)
+			p, err := proc.fuzzer.target.Deserialize(pq.Prog, prog.NonStrict)
+			if err != nil {
+				log.Fatalf("checkArgsQueueLoop: failed to parse program from manager: %v", err)
+			}
+			//sig := hash.Hash(pq.Prog)
+			//sign := pq.Prog.Signal.Deserialize()
+			//fuzzer.addInputToCorpus(p, sign, sig)
+			flags := ProgNormal
+			prog.NOfCalls = pq.NOfCalls
+			prog.PocProg = string(pq.PocProg)
+			if strings.Compare(string(pq.Prog), string(p.Serialize())) != 0 {
+				prog.PocProg = string(p.Serialize())
+				log.Logf(0, "Prog is not minimized\n")
+			}
+			proc.fuzzer.workQueue.enqueue(&WorkCandidate{
+				p:     p,
+				flags: flags,
+			})
+		}
+		time.Sleep(10 * time.Second)
+	}
+}
diff --git a/syz-fuzzer/testing.go b/syz-fuzzer/testing.go
index 2ed615c8..9cf289dd 100644
--- a/syz-fuzzer/testing.go
+++ b/syz-fuzzer/testing.go
@@ -193,7 +193,8 @@ func checkCalls(args *checkArgs, features *host.Features) (*rpctype.CheckArgs, e
 }
 
 func checkRevisions(args *checkArgs) error {
-	log.Logf(0, "checking revisions...")
+	//log.Logf(0, "checking revisions!...")
+	log.Logf(0, "checkRevisions prog.GitRevision %v", prog.GitRevision)
 	executorArgs := strings.Split(args.ipcConfig.Executor, " ")
 	executorArgs = append(executorArgs, "version")
 	cmd := osutil.Command(executorArgs[0], executorArgs[1:]...)
diff --git a/syz-fuzzer/workqueue.go b/syz-fuzzer/workqueue.go
index 62648336..e31b664a 100644
--- a/syz-fuzzer/workqueue.go
+++ b/syz-fuzzer/workqueue.go
@@ -5,6 +5,7 @@ package main
 
 import (
 	"sync"
+	"time"
 
 	"github.com/google/syzkaller/pkg/ipc"
 	"github.com/google/syzkaller/prog"
@@ -20,6 +21,7 @@ type WorkQueue struct {
 	candidate       []*WorkCandidate
 	triage          []*WorkTriage
 	smash           []*WorkSmash
+	grow            []*WorkGrow
 
 	procs          int
 	needCandidates chan struct{}
@@ -61,6 +63,11 @@ type WorkSmash struct {
 	call int
 }
 
+type WorkGrow struct {
+	p     *prog.Prog
+	flags ProgTypes
+}
+
 func newWorkQueue(procs int, needCandidates chan struct{}) *WorkQueue {
 	return &WorkQueue{
 		procs:          procs,
@@ -71,6 +78,7 @@ func newWorkQueue(procs int, needCandidates chan struct{}) *WorkQueue {
 func (wq *WorkQueue) enqueue(item interface{}) {
 	wq.mu.Lock()
 	defer wq.mu.Unlock()
+	lastEnqueue = time.Now()
 	switch item := item.(type) {
 	case *WorkTriage:
 		if item.flags&ProgCandidate != 0 {
@@ -82,6 +90,8 @@ func (wq *WorkQueue) enqueue(item interface{}) {
 		wq.candidate = append(wq.candidate, item)
 	case *WorkSmash:
 		wq.smash = append(wq.smash, item)
+	case *WorkGrow:
+		wq.grow = append(wq.grow, item)
 	default:
 		panic("unknown work type")
 	}
@@ -89,7 +99,7 @@ func (wq *WorkQueue) enqueue(item interface{}) {
 
 func (wq *WorkQueue) dequeue() (item interface{}) {
 	wq.mu.RLock()
-	if len(wq.triageCandidate)+len(wq.candidate)+len(wq.triage)+len(wq.smash) == 0 {
+	if len(wq.triageCandidate)+len(wq.candidate)+len(wq.triage)+len(wq.smash)+len(wq.grow) == 0 {
 		wq.mu.RUnlock()
 		return nil
 	}
@@ -113,6 +123,10 @@ func (wq *WorkQueue) dequeue() (item interface{}) {
 		last := len(wq.smash) - 1
 		item = wq.smash[last]
 		wq.smash = wq.smash[:last]
+	} else if len(wq.grow) != 0 {
+		last := len(wq.grow) - 1
+		item = wq.grow[last]
+		wq.grow = wq.grow[:last]
 	}
 	wq.mu.Unlock()
 	if wantCandidates {
diff --git a/syz-manager/manager.go b/syz-manager/manager.go
index 2a0b7dd4..63413f3b 100644
--- a/syz-manager/manager.go
+++ b/syz-manager/manager.go
@@ -6,6 +6,7 @@ package main
 import (
 	"bytes"
 	"encoding/json"
+	"errors"
 	"flag"
 	"fmt"
 	"math/rand"
@@ -13,10 +14,13 @@ import (
 	"os"
 	"os/exec"
 	"path/filepath"
+	"strconv"
+	"strings"
 	"sync"
 	"sync/atomic"
 	"time"
 
+	"github.com/google/syzkaller/courier"
 	"github.com/google/syzkaller/dashboard/dashapi"
 	"github.com/google/syzkaller/pkg/cover"
 	"github.com/google/syzkaller/pkg/csource"
@@ -41,8 +45,11 @@ var (
 	flagConfig = flag.String("config", "", "configuration file")
 	flagDebug  = flag.Bool("debug", false, "dump all VM output to console")
 	flagBench  = flag.String("bench", "", "write execution statistics into this file periodically")
+	flagPoC    = flag.Bool("poc", false, "mutate base on current PoC")
 )
 
+var shutdownErr = errors.New("An error to shutdown all vms")
+
 type Manager struct {
 	cfg            *mgrconfig.Config
 	vmPool         *vm.Pool
@@ -267,6 +274,8 @@ func RunManager(cfg *mgrconfig.Config, target *prog.Target, sysTarget *targets.T
 		<-vm.Shutdown
 		return
 	}
+	TestcasePath = cfg.Testcase
+	courier.AnalyzerPath = cfg.AnalyzerDir
 	mgr.vmLoop()
 }
 
@@ -311,6 +320,8 @@ func (mgr *Manager) vmLoop() {
 	reproDone := make(chan *ReproResult, 1)
 	stopPending := false
 	shutdown := vm.Shutdown
+	succeed := 0
+	start := time.Now()
 	for shutdown != nil || len(instances) != vmCount {
 		mgr.mu.Lock()
 		phase := mgr.phase
@@ -367,7 +378,14 @@ func (mgr *Manager) vmLoop() {
 				instances = instances[:last]
 				log.Logf(1, "loop: starting instance %v", idx)
 				go func() {
-					crash, err := mgr.runInstance(idx)
+					timeLimit, err := strconv.Atoi(mgr.cfg.TimeLimit)
+					if err != nil {
+						timeLimit = 8
+					}
+					crash, err := mgr.runInstance(idx, start, timeLimit-succeed)
+					if crash == nil && err == shutdownErr && len(reproQueue)+len(pendingRepro)+len(reproducing) == 0 {
+						shutdown = nil
+					}
 					runDone <- &RunResult{idx, crash, err}
 				}()
 			}
@@ -387,6 +405,10 @@ func (mgr *Manager) vmLoop() {
 			stopPending = true
 		case res := <-runDone:
 			log.Logf(1, "loop: instance %v finished, crash=%v", res.idx, res.crash != nil)
+			if *flagPoC && res.crash != nil && res.crash.Report.Title == vm.NoOutputCrash {
+				log.Logf(0, "exit due to no output for a long time")
+				shutdown = nil
+			}
 			if res.err != nil && shutdown != nil {
 				log.Logf(0, "%v", res.err)
 			}
@@ -423,6 +445,17 @@ func (mgr *Manager) vmLoop() {
 				}
 			} else {
 				mgr.saveRepro(res.res, res.stats, res.hub)
+				log.Logf(0, "SaveRepro %s", res.res.Report.Title)
+				if succeed == 0 && strings.Contains(res.res.Report.Title, "out-of-bounds Write") ||
+					strings.Contains(res.res.Report.Title, "use-after-free Write") {
+					succeed++
+					log.Logf(0, "Save to success file")
+					courier.SaveToFile("success")
+					if courier.ConfirmedSuccess {
+						courier.SaveToFile("confirmedSuccess")
+						courier.ConfirmedSuccess = false
+					}
+				}
 			}
 		case <-shutdown:
 			log.Logf(1, "loop: shutting down...")
@@ -528,7 +561,7 @@ func (mgr *Manager) loadCorpus() {
 	mgr.phase = phaseLoadedCorpus
 }
 
-func (mgr *Manager) runInstance(index int) (*Crash, error) {
+func (mgr *Manager) runInstance(index int, managerStart time.Time, timeLimit int) (*Crash, error) {
 	mgr.checkUsedFiles()
 	inst, err := mgr.vmPool.Create(index)
 	if err != nil {
@@ -569,14 +602,17 @@ func (mgr *Manager) runInstance(index int) (*Crash, error) {
 	defer atomic.AddUint32(&mgr.numFuzzing, ^uint32(0))
 	cmd := instance.FuzzerCmd(fuzzerBin, executorCmd, fmt.Sprintf("vm-%v", index),
 		mgr.cfg.TargetOS, mgr.cfg.TargetArch, fwdAddr, mgr.cfg.Sandbox, procs, fuzzerV,
-		mgr.cfg.Cover, *flagDebug, false, false)
+		mgr.cfg.Cover, *flagDebug, false, false, *flagPoC)
 	outc, errc, err := inst.Run(time.Hour, mgr.vmStop, cmd)
 	if err != nil {
 		return nil, fmt.Errorf("failed to run fuzzer: %v", err)
 	}
 
-	rep := inst.MonitorExecution(outc, errc, mgr.reporter, vm.ExitTimeout)
+	rep := inst.MonitorExecution(outc, errc, mgr.reporter, vm.ExitTimeout, managerStart, timeLimit)
 	if rep == nil {
+		if time.Since(managerStart) >= time.Duration(timeLimit)*time.Hour {
+			return nil, shutdownErr
+		}
 		// This is the only "OK" outcome.
 		log.Logf(0, "vm-%v: running for %v, restarting", index, time.Since(start))
 		return nil, nil
diff --git a/syz-manager/rpc.go b/syz-manager/rpc.go
index 91e31dbd..ddbdb8e2 100644
--- a/syz-manager/rpc.go
+++ b/syz-manager/rpc.go
@@ -10,6 +10,7 @@ import (
 	"sync"
 	"time"
 
+	"github.com/google/syzkaller/courier"
 	"github.com/google/syzkaller/pkg/cover"
 	"github.com/google/syzkaller/pkg/log"
 	"github.com/google/syzkaller/pkg/rpctype"
@@ -54,6 +55,7 @@ type RPCManagerView interface {
 	newInput(inp rpctype.RPCInput, sign signal.Signal) bool
 	candidateBatch(size int) []rpctype.RPCCandidate
 	rotateCorpus() bool
+	parseCustomizedTestcase(a rpctype.GetCallsFromFuzzerArgs) error
 }
 
 func startRPCServer(mgr *Manager) (int, error) {
@@ -309,3 +311,43 @@ func (serv *RPCServer) Poll(a *rpctype.PollArgs, r *rpctype.PollRes) error {
 		a.Name, len(r.Candidates), len(r.NewInputs), len(r.MaxSignal.Elems))
 	return nil
 }
+
+func (serv *RPCServer) GetQueueLen(a *rpctype.GetQueueLenArgs, r *rpctype.GetQueueLenRes) error {
+	switch a.Flag {
+	case courier.Mutating:
+		r.Length = len(courier.MutateArgsQueue)
+		break
+	case courier.Commands:
+		r.Length = len(courier.CommandsQueue)
+		break
+	case courier.S2E:
+		r.Length = len(courier.S2EArgsQueue)
+	}
+	return nil
+}
+
+func (serv *RPCServer) RetrieveArgsQueue(a *rpctype.ProgQueue, pq *rpctype.ProgQueue) error {
+	courier.Mutex.Lock()
+	p := courier.RetrieveFirstArg(courier.Mutating)
+	if p != nil {
+		*pq = p.(rpctype.ProgQueue)
+	}
+	courier.Mutex.Unlock()
+	return nil
+}
+
+func (serv *RPCServer) EmitSignal(a *rpctype.FuzzerSignal, pq *rpctype.FuzzerSignal) error {
+	courier.Mutex.Lock()
+	sg := a.Signal
+	log.Logf(0, "A signal from fuzzer: %s\n", sg)
+	courier.Mutex.Unlock()
+	return nil
+}
+
+func (serv *RPCServer) GetCallsFromFuzzer(a *rpctype.GetCallsFromFuzzerArgs, r *int) error {
+	err := serv.mgr.parseCustomizedTestcase(*a)
+	if err != nil {
+		log.Logf(0, "%v", err)
+	}
+	return nil
+}
diff --git a/syz-manager/utilities.go b/syz-manager/utilities.go
new file mode 100644
index 00000000..1c243a31
--- /dev/null
+++ b/syz-manager/utilities.go
@@ -0,0 +1,64 @@
+package main
+
+import (
+	"fmt"
+	"io/ioutil"
+	"math/rand"
+	_ "net/http/pprof"
+	"os"
+	"time"
+
+	"github.com/google/syzkaller/courier"
+	"github.com/google/syzkaller/pkg/log"
+	"github.com/google/syzkaller/pkg/rpctype"
+	"github.com/google/syzkaller/prog"
+)
+
+var TestcasePath string
+var flagParseTestcase = false
+
+//Read and parse testcase, send it to fuzzer
+func (mgr *Manager) parseCustomizedTestcase(a rpctype.GetCallsFromFuzzerArgs) error {
+	if flagParseTestcase {
+		return nil
+	}
+	flagParseTestcase = true
+	var corpus []*prog.Prog
+	info, err := os.Stat(TestcasePath)
+	if !os.IsNotExist(err) {
+		if !info.IsDir() {
+			fileCache, err := os.Open(TestcasePath)
+			if err != nil {
+				return err
+			}
+			defer fileCache.Close()
+			testcase_raw, err := ioutil.ReadFile(TestcasePath)
+			if err != nil {
+				return err
+			}
+			testcase := courier.RemoveComments(testcase_raw)
+			log.Logf(0, "testcase: %s\n", testcase)
+			calls := make(map[*prog.Syscall]bool)
+			rnd := rand.New(rand.NewSource(time.Now().UnixNano() + int64(4)*1e12))
+			for _, id := range a.EnabledCalls[a.Sandbox] {
+				calls[mgr.target.Syscalls[id]] = true
+			}
+			prios := mgr.target.CalculatePriorities(corpus)
+			choiceTable := mgr.target.BuildChoiceTable(prios, calls)
+			p, err := mgr.target.Deserialize(testcase, prog.NonStrict)
+			if err != nil {
+				return fmt.Errorf("Fail to parse testcase: %v", err)
+			}
+			prog.NOfCalls = len(p.Calls)
+			prog.PocProg = string(testcase)
+			courier.AppendTestcase(testcase, testcase, prog.NOfCalls)
+			for i := 0; i < 100; i++ {
+				p := p.Clone()
+				p.Mutate(rnd, prog.RecommendedCalls, choiceTable, corpus)
+				courier.AppendTestcase(p.Serialize(), []byte(prog.PocProg), prog.NOfCalls)
+			}
+			return nil
+		}
+	}
+	return err
+}
diff --git a/tools/syz-crush/crush.go b/tools/syz-crush/crush.go
index 33b9ccef..6796b061 100644
--- a/tools/syz-crush/crush.go
+++ b/tools/syz-crush/crush.go
@@ -113,7 +113,7 @@ func runInstance(cfg *mgrconfig.Config, reporter report.Reporter, vmPool *vm.Poo
 	}
 
 	log.Logf(0, "vm-%v: crushing...", index)
-	rep := inst.MonitorExecution(outc, errc, reporter, vm.ExitTimeout)
+	rep := inst.MonitorExecution(outc, errc, reporter, vm.ExitTimeout, time.Now(), -1)
 	if rep == nil {
 		// This is the only "OK" outcome.
 		log.Logf(0, "vm-%v: running long enough, restarting", index)
diff --git a/tools/syz-runtest/runtest.go b/tools/syz-runtest/runtest.go
index e7b41be6..652bdc5b 100644
--- a/tools/syz-runtest/runtest.go
+++ b/tools/syz-runtest/runtest.go
@@ -187,12 +187,12 @@ func (mgr *Manager) boot(name string, index int) (*report.Report, error) {
 	}
 	cmd := instance.FuzzerCmd(fuzzerBin, executorCmd, name,
 		mgr.cfg.TargetOS, mgr.cfg.TargetArch, fwdAddr, mgr.cfg.Sandbox, mgr.cfg.Procs, 0,
-		mgr.cfg.Cover, mgr.debug, false, true)
+		mgr.cfg.Cover, mgr.debug, false, true, false)
 	outc, errc, err := inst.Run(time.Hour, mgr.vmStop, cmd)
 	if err != nil {
 		return nil, fmt.Errorf("failed to run fuzzer: %v", err)
 	}
-	rep := inst.MonitorExecution(outc, errc, mgr.reporter, vm.ExitNormal)
+	rep := inst.MonitorExecution(outc, errc, mgr.reporter, vm.ExitNormal, time.Now(), -1)
 	return rep, nil
 }
 
diff --git a/vm/qemu/qemu.go b/vm/qemu/qemu.go
index bddace8f..64f52e90 100644
--- a/vm/qemu/qemu.go
+++ b/vm/qemu/qemu.go
@@ -186,7 +186,7 @@ var linuxCmdline = []string{
 	"earlyprintk=serial",
 	"oops=panic",
 	"nmi_watchdog=panic",
-	"panic_on_warn=1",
+	//"panic_on_warn=1",
 	"panic=1",
 	"ftrace_dump_on_oops=orig_cpu",
 	"rodata=n",
@@ -383,6 +383,7 @@ func (inst *instance) boot() error {
 			)
 		}
 		cmdline = append(cmdline, inst.cfg.Cmdline)
+		cmdline = append(cmdline, "kasan_multi_shot=1")
 		args = append(args,
 			"-kernel", inst.cfg.Kernel,
 			"-append", strings.Join(cmdline, " "),
diff --git a/vm/vm.go b/vm/vm.go
index 0bd13a95..33b064a7 100644
--- a/vm/vm.go
+++ b/vm/vm.go
@@ -15,6 +15,7 @@ import (
 	"path/filepath"
 	"time"
 
+	"github.com/google/syzkaller/pkg/log"
 	"github.com/google/syzkaller/pkg/mgrconfig"
 	"github.com/google/syzkaller/pkg/osutil"
 	"github.com/google/syzkaller/pkg/report"
@@ -162,7 +163,7 @@ const (
 // Exit says which exit modes should be considered as errors/OK.
 // Returns a non-symbolized crash report, or nil if no error happens.
 func (inst *Instance) MonitorExecution(outc <-chan []byte, errc <-chan error,
-	reporter report.Reporter, exit ExitCondition) (rep *report.Report) {
+	reporter report.Reporter, exit ExitCondition, managerStart time.Time, timeLimit int) (rep *report.Report) {
 	mon := &monitor{
 		inst:     inst,
 		outc:     outc,
@@ -233,6 +234,10 @@ func (inst *Instance) MonitorExecution(outc <-chan []byte, errc <-chan error,
 			if mon.matchPos < 0 {
 				mon.matchPos = 0
 			}
+			if timeLimit >= 0 && time.Since(managerStart) >= time.Duration(timeLimit)*time.Hour {
+				log.Logf(0, "running for %d hours, exit now.", timeLimit)
+				return nil
+			}
 		case <-ticker.C:
 			// Detect both "not output whatsoever" and "kernel episodically prints
 			// something to console, but fuzzer is not actually executing programs".
@@ -257,7 +262,7 @@ func (inst *Instance) MonitorExecution(outc <-chan []byte, errc <-chan error,
 				mon.waitForOutput()
 			}
 			rep := &report.Report{
-				Title:      noOutputCrash,
+				Title:      NoOutputCrash,
 				Output:     mon.output,
 				Suppressed: report.IsSuppressed(mon.reporter, mon.output),
 			}
@@ -355,7 +360,7 @@ const (
 	maxErrorLength = 256
 
 	lostConnectionCrash  = "lost connection to test machine"
-	noOutputCrash        = "no output from test machine"
+	NoOutputCrash        = "no output from test machine"
 	timeoutCrash         = "timed out"
 	executingProgramStr1 = "executing program"  // syz-fuzzer output
 	executingProgramStr2 = "executed programs:" // syz-execprog output
diff --git a/vm/vm_test.go b/vm/vm_test.go
index 6f7f1848..8d894444 100644
--- a/vm/vm_test.go
+++ b/vm/vm_test.go
@@ -243,7 +243,7 @@ var tests = []*Test{
 		Body: func(outc chan []byte, errc chan error) {
 		},
 		Report: &report.Report{
-			Title: noOutputCrash,
+			Title: NoOutputCrash,
 		},
 	},
 	{
@@ -255,7 +255,7 @@ var tests = []*Test{
 			}
 		},
 		Report: &report.Report{
-			Title: noOutputCrash,
+			Title: NoOutputCrash,
 		},
 	},
 	{
@@ -370,7 +370,7 @@ func testMonitorExecution(t *testing.T, test *Test) {
 		test.Body(testInst.outc, testInst.errc)
 		done <- true
 	}()
-	rep := inst.MonitorExecution(outc, errc, reporter, test.Exit)
+	rep := inst.MonitorExecution(outc, errc, reporter, test.Exit, time.Now(), -1)
 	<-done
 	if test.Report != nil && rep == nil {
 		t.Fatalf("got no report")
