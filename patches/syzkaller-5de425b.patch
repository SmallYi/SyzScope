diff --git a/courier/queue.go b/courier/queue.go
new file mode 100644
index 00000000..9808fcc0
--- /dev/null
+++ b/courier/queue.go
@@ -0,0 +1,62 @@
+package courier
+
+import (
+	"sync"
+)
+
+const (
+	Mutating = 0
+	Commands = 1
+	S2E      = 2
+)
+
+type S2EArgs struct {
+	Prog    []byte
+	Pointer []byte
+}
+
+var MutateArgsQueue = make([]string, 0)
+
+var CommandsQueue = make([]string, 0)
+var S2EArgsQueue = make([]S2EArgs, 0)
+var Mutex = &sync.Mutex{}
+
+//Append testcase to a queue waits for mutating
+func AppendMutatingQueue(p []byte) {
+	MutateArgsQueue = append(MutateArgsQueue, string(p))
+}
+
+func AppendCommandsQueue(p []byte) {
+	CommandsQueue = append(CommandsQueue, string(p))
+}
+
+func AppendS2EQueue(p S2EArgs) {
+	S2EArgsQueue = append(S2EArgsQueue, p)
+}
+
+func RetrieveFirstArg(flag int) interface{} {
+	switch flag {
+	case Mutating:
+		if len(MutateArgsQueue) == 0 {
+			break
+		}
+		p := MutateArgsQueue[0]
+		MutateArgsQueue = MutateArgsQueue[1:]
+		return []byte(p)
+	case Commands:
+		if len(CommandsQueue) == 0 {
+			break
+		}
+		p := CommandsQueue[0]
+		CommandsQueue = CommandsQueue[1:]
+		return []byte(p)
+	case S2E:
+		if len(S2EArgsQueue) == 0 {
+			break
+		}
+		p := S2EArgsQueue[0]
+		S2EArgsQueue = S2EArgsQueue[1:]
+		return p
+	}
+	return nil
+}
diff --git a/pkg/mgrconfig/config.go b/pkg/mgrconfig/config.go
index ea03c429..434a928b 100644
--- a/pkg/mgrconfig/config.go
+++ b/pkg/mgrconfig/config.go
@@ -99,4 +99,5 @@ type Config struct {
 	SyzFuzzerBin   string `json:"-"`
 	SyzExecprogBin string `json:"-"`
 	SyzExecutorBin string `json:"-"`
+	Testcase       string `json:"testcase"`
 }
diff --git a/pkg/rpctype/rpctype.go b/pkg/rpctype/rpctype.go
index 61d98dac..1d45801c 100644
--- a/pkg/rpctype/rpctype.go
+++ b/pkg/rpctype/rpctype.go
@@ -127,3 +127,16 @@ type RunTestDoneArgs struct {
 	Info   []*ipc.ProgInfo
 	Error  string
 }
+
+type ProgQueue struct {
+	Length int
+	Prog   []byte
+}
+
+type GetQueueLenArgs struct {
+	Flag int
+}
+
+type GetQueueLenRes struct {
+	Length int
+}
diff --git a/prog/minimization.go b/prog/minimization.go
index 9a71dd06..e3f64e0c 100644
--- a/prog/minimization.go
+++ b/prog/minimization.go
@@ -31,7 +31,7 @@ func Minimize(p0 *Prog, callIndex0 int, crash bool, pred0 func(*Prog, int) bool)
 	p0, callIndex0 = removeCalls(p0, callIndex0, crash, pred)
 
 	// Try to minimize individual args.
-	for i := 0; i < len(p0.Calls); i++ {
+	for i := NOfCalls; i < len(p0.Calls); i++ {
 		ctx := &minimizeArgsCtx{
 			target:     p0.Target,
 			p0:         &p0,
@@ -60,7 +60,7 @@ func Minimize(p0 *Prog, callIndex0 int, crash bool, pred0 func(*Prog, int) bool)
 }
 
 func removeCalls(p0 *Prog, callIndex0 int, crash bool, pred func(*Prog, int) bool) (*Prog, int) {
-	for i := len(p0.Calls) - 1; i >= 0; i-- {
+	for i := len(p0.Calls) - 1; i >= NOfCalls; i-- {
 		if i == callIndex0 {
 			continue
 		}
diff --git a/prog/mutation.go b/prog/mutation.go
index 1031217b..09808914 100644
--- a/prog/mutation.go
+++ b/prog/mutation.go
@@ -31,19 +31,24 @@ func (p *Prog) Mutate(rs rand.Source, ncalls int, ct *ChoiceTable, corpus []*Pro
 		corpus: corpus,
 	}
 	for stop, ok := false, false; !stop; stop = ok && r.oneOf(3) {
+		if len(p.Calls) == NOfCalls {
+			ctx.insertCallAtEnd()
+		}
 		switch {
 		case r.oneOf(5):
 			// Not all calls have anything squashable,
 			// so this has lower priority in reality.
-			ok = ctx.squashAny()
+			ok = ctx.squashAnyCus()
 		case r.nOutOf(1, 100):
-			ok = ctx.splice()
+			ok = ctx.spliceCus()
 		case r.nOutOf(20, 31):
-			ok = ctx.insertCall()
+			ok = ctx.insertCallCus()
 		case r.nOutOf(10, 11):
-			ok = ctx.mutateArg()
+			ok = ctx.mutateArgCus()
 		default:
-			ok = ctx.removeCall()
+			if len(p.Calls) > NOfCalls {
+				ok = ctx.removeCallCus()
+			}
 		}
 	}
 	for _, c := range p.Calls {
diff --git a/prog/mutation_custom.go b/prog/mutation_custom.go
new file mode 100644
index 00000000..afff5da2
--- /dev/null
+++ b/prog/mutation_custom.go
@@ -0,0 +1,236 @@
+package prog
+
+import (
+	"fmt"
+	"strings"
+)
+
+var NOfCalls = 0
+var PocProg string
+
+func (ctx *mutator) spliceCus() bool {
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return ctx.splice()
+	}
+	if len(ctx.corpus) == 0 || len(p.Calls)-NOfCalls <= 0 || len(p.Calls) >= ctx.ncalls {
+		return false
+	}
+	p0 := ctx.corpus[r.Intn(len(ctx.corpus))]
+	p0c := p0.Clone()
+	idx := r.Intn(len(p.Calls)-NOfCalls) + NOfCalls
+	p.Calls = append(p.Calls[:idx], append(p0c.Calls, p.Calls[idx:]...)...)
+	for i := len(p.Calls) - 1; i >= ctx.ncalls; i-- {
+		p.removeCall(i)
+	}
+	return true
+}
+
+// Picks a random complex pointer and squashes its arguments into an ANY.
+// Subsequently, if the ANY contains blobs, mutates a random blob.
+func (ctx *mutator) squashAnyCus() bool {
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return ctx.squashAny()
+	}
+	complexPtrs := p.complexPtrsCus()
+	if len(complexPtrs) == 0 {
+		return false
+	}
+	ptr := complexPtrs[r.Intn(len(complexPtrs))]
+	if !p.Target.isAnyPtr(ptr.Type()) {
+		p.Target.squashPtr(ptr, true)
+	}
+	var blobs []*DataArg
+	var bases []*PointerArg
+	ForeachSubArg(ptr, func(arg Arg, ctx *ArgCtx) {
+		if data, ok := arg.(*DataArg); ok && arg.Type().Dir() != DirOut {
+			blobs = append(blobs, data)
+			bases = append(bases, ctx.Base)
+		}
+	})
+	if len(blobs) == 0 {
+		return false
+	}
+	// TODO(dvyukov): we probably want special mutation for ANY.
+	// E.g. merging adjacent ANYBLOBs (we don't create them,
+	// but they can appear in future); or replacing ANYRES
+	// with a blob (and merging it with adjacent blobs).
+	idx := r.Intn(len(blobs))
+	arg := blobs[idx]
+	base := bases[idx]
+	baseSize := base.Res.Size()
+	arg.data = mutateData(r, arg.Data(), 0, maxBlobLen)
+	// Update base pointer if size has increased.
+	if baseSize < base.Res.Size() {
+		s := analyze(ctx.ct, ctx.corpus, p, p.Calls[0])
+		newArg := r.allocAddr(s, base.Type(), base.Res.Size(), base.Res)
+		*base = *newArg
+	}
+	return true
+}
+
+func (ctx *mutator) insertCallAtEnd() bool {
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return true
+	}
+	if len(p.Calls) >= ctx.ncalls {
+		return false
+	}
+	idx := len(p.Calls)
+	var c *Call
+	if idx < len(p.Calls) {
+		c = p.Calls[idx]
+	}
+	s := analyze(ctx.ct, ctx.corpus, p, c)
+	calls := r.generateCall(s, p)
+	// TODO: the program might have more than ncalls
+	p.insertBefore(c, calls)
+	for len(p.Calls) > ctx.ncalls {
+		p.removeCall(idx)
+	}
+	return true
+}
+
+func (ctx *mutator) insertCallCus() bool {
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return ctx.insertCall()
+	}
+	if len(p.Calls) >= ctx.ncalls {
+		return false
+	}
+	idx := r.biasedRand(len(p.Calls)+1-NOfCalls, 5) + NOfCalls
+	if NOfCalls == len(p.Calls) {
+		idx = len(p.Calls)
+	}
+	var c *Call
+	if idx < len(p.Calls) {
+		c = p.Calls[idx]
+	}
+	s := analyze(ctx.ct, ctx.corpus, p, c)
+	calls := r.generateCall(s, p)
+	// TODO: the program might have more than ncalls
+	p.insertBefore(c, calls)
+	for len(p.Calls) > ctx.ncalls {
+		p.removeCall(idx)
+	}
+	return true
+}
+
+// Removes a random call from program.
+func (ctx *mutator) removeCallCus() bool {
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return ctx.removeCall()
+	}
+	if len(p.Calls) == 0 {
+		return false
+	}
+	idx := r.Intn(len(p.Calls)-NOfCalls) + NOfCalls
+	p.removeCall(idx)
+	return true
+}
+
+// Mutate an argument of a random call.
+func (ctx *mutator) mutateArgCus() bool {
+	start := NOfCalls
+	p, r := ctx.p, ctx.r
+	if !containPoC(p.Serialize()) {
+		return ctx.mutateArg()
+	}
+	if len(p.Calls) == 0 {
+		return false
+	}
+	idx := chooseCallCus(p, r, start)
+	if idx < 0 {
+		return false
+	}
+	c := p.Calls[idx]
+	updateSizes := true
+	for stop, ok := false, false; !stop; stop = ok && r.oneOf(3) {
+		ok = true
+		ma := &mutationArgs{target: p.Target}
+		ForeachArg(c, ma.collectArg)
+		if len(ma.args) == 0 {
+			return false
+		}
+		s := analyze(ctx.ct, ctx.corpus, p, c)
+		chosenIdx := randomChoice(ma.priorities, r)
+		arg, argCtx := ma.args[chosenIdx], ma.ctxes[chosenIdx]
+		calls, ok1 := p.Target.mutateArg(r, s, arg, argCtx, &updateSizes)
+		if !ok1 {
+			ok = false
+			continue
+		}
+		p.insertBefore(c, calls)
+		idx += len(calls)
+		for len(p.Calls) > ctx.ncalls {
+			idx--
+			p.removeCall(idx)
+		}
+		if idx < 0 || idx >= len(p.Calls) || p.Calls[idx] != c {
+			panic(fmt.Sprintf("wrong call index: idx=%v calls=%v p.Calls=%v ncalls=%v",
+				idx, len(calls), len(p.Calls), ctx.ncalls))
+		}
+		if updateSizes {
+			p.Target.assignSizesCall(c)
+		}
+	}
+	return true
+}
+
+// Select a call based on the complexity of the arguments.
+func chooseCallCus(p *Prog, r *randGen, start int) int {
+	var callPriorities []float64
+	noArgs := true
+
+	for i, c := range p.Calls {
+		if i < start {
+			continue
+		}
+		totalPrio := float64(0)
+		ForeachArg(c, func(arg Arg, ctx *ArgCtx) {
+			prio, stopRecursion := arg.Type().getMutationPrio(p.Target, arg, false)
+			totalPrio += prio
+			ctx.Stop = stopRecursion
+		})
+		callPriorities = append(callPriorities, totalPrio)
+		if len(c.Args) > 0 {
+			noArgs = false
+		}
+	}
+
+	// Calls without arguments.
+	if noArgs {
+		return -1
+	}
+	return start + randomChoice(callPriorities, r)
+}
+
+func (p *Prog) complexPtrsCus() (res []*PointerArg) {
+	for i, c := range p.Calls {
+		if i < NOfCalls {
+			continue
+		}
+		ForeachArg(c, func(arg Arg, ctx *ArgCtx) {
+			if ptrArg, ok := arg.(*PointerArg); ok && p.Target.isComplexPtr(ptrArg) {
+				res = append(res, ptrArg)
+				ctx.Stop = true
+			}
+		})
+	}
+	return
+}
+
+func containPoC(prog []byte) bool {
+	sProg := string(prog)
+	if len(sProg) < len(PocProg) {
+		return false
+	}
+	if strings.Compare(PocProg, sProg[:len(PocProg)]) == 0 {
+		return true
+	}
+	return false
+}
diff --git a/syz-fuzzer/fuzzer.go b/syz-fuzzer/fuzzer.go
index 22387135..5f2d080f 100644
--- a/syz-fuzzer/fuzzer.go
+++ b/syz-fuzzer/fuzzer.go
@@ -92,6 +92,9 @@ const (
 	OutputFile
 )
 
+var executePoCOnly = true
+var lastEnqueue time.Time
+
 func main() {
 	debug.SetGCPercent(50)
 
@@ -248,6 +251,13 @@ func main() {
 		go proc.loop()
 	}
 
+	MutatingLoop, err1 := newProc(fuzzer, *flagProcs)
+	if err1 != nil {
+		log.Fatalf("failed to create proc: %v", err)
+	}
+	fuzzer.procs = append(fuzzer.procs, MutatingLoop)
+	go MutatingLoop.checkMutatingQueueLoop()
+
 	fuzzer.pollLoop()
 }
 
@@ -292,6 +302,10 @@ func (fuzzer *Fuzzer) pollLoop() {
 			log.Logf(0, "alive, executed %v", execTotal)
 			lastPrint = time.Now()
 		}
+		if time.Since(lastEnqueue) > 3*time.Minute && time.Since(lastEnqueue) < 5*time.Minute && executePoCOnly {
+			log.Logf(0, "set fuzzer free")
+			executePoCOnly = false
+		}
 		if poll || time.Since(lastPoll) > 10*time.Second {
 			needCandidates := fuzzer.workQueue.wantCandidates()
 			if poll && !needCandidates {
@@ -332,6 +346,7 @@ func (fuzzer *Fuzzer) poll(needCandidates bool, stats map[string]uint64) bool {
 	for _, inp := range r.NewInputs {
 		fuzzer.addInputFromAnotherFuzzer(inp)
 	}
+	if !executePoCOnly {
 	for _, candidate := range r.Candidates {
 		p, err := fuzzer.target.Deserialize(candidate.Prog, prog.NonStrict)
 		if err != nil {
@@ -349,6 +364,7 @@ func (fuzzer *Fuzzer) poll(needCandidates bool, stats map[string]uint64) bool {
 			flags: flags,
 		})
 	}
+	}
 	if needCandidates && len(r.Candidates) == 0 && atomic.LoadUint32(&fuzzer.triagedCandidates) == 0 {
 		atomic.StoreUint32(&fuzzer.triagedCandidates, 1)
 	}
diff --git a/syz-fuzzer/proc.go b/syz-fuzzer/proc.go
index 3b884b2a..ca8169b3 100644
--- a/syz-fuzzer/proc.go
+++ b/syz-fuzzer/proc.go
@@ -9,10 +9,12 @@ import (
 	"math/rand"
 	"os"
 	"runtime/debug"
+	"strings"
 	"sync/atomic"
 	"syscall"
 	"time"
 
+	"github.com/google/syzkaller/courier"
 	"github.com/google/syzkaller/pkg/cover"
 	"github.com/google/syzkaller/pkg/hash"
 	"github.com/google/syzkaller/pkg/ipc"
@@ -80,12 +82,15 @@ func (proc *Proc) loop() {
 				proc.execute(proc.execOpts, item.p, item.flags, StatCandidate)
 			case *WorkSmash:
 				proc.smashInput(item)
+			case *WorkGrow:
+				proc.growInput(proc.execOpts, item, StatCandidate)
 			default:
 				log.Fatalf("unknown work type: %#v", item)
 			}
 			continue
 		}
 
+		if !executePoCOnly {
 		ct := proc.fuzzer.choiceTable
 		corpus := proc.fuzzer.corpusSnapshot()
 		if len(corpus) == 0 || i%generatePeriod == 0 {
@@ -100,6 +105,7 @@ func (proc *Proc) loop() {
 			log.Logf(1, "#%v: mutated", proc.pid)
 			proc.execute(proc.execOpts, p, ProgNormal, StatFuzz)
 		}
+		}
 	}
 }
 
@@ -181,6 +187,18 @@ func (proc *Proc) triageInput(item *WorkTriage) {
 	}
 }
 
+func (proc *Proc) growInput(execOpts *ipc.ExecOpts, item *WorkGrow, stat Stat) {
+	log.Logf(1, "#%v: growInput type=%x", proc.pid, item.flags)
+
+	proc.executeRaw(execOpts, item.p, stat)
+	corpus := proc.fuzzer.corpusSnapshot()
+	for i := 0; i < 100; i++ {
+		p := item.p.Clone()
+		p.Mutate(proc.rnd, programLength, proc.fuzzer.choiceTable, corpus)
+		proc.execute(proc.execOpts, p, ProgNormal, StatSmash)
+	}
+}
+
 func reexecutionSuccess(info *ipc.ProgInfo, oldInfo *ipc.CallInfo, call int) bool {
 	if info == nil || len(info.Calls) == 0 {
 		return false
@@ -254,7 +272,10 @@ func (proc *Proc) executeHintSeed(p *prog.Prog, call int) {
 func (proc *Proc) execute(execOpts *ipc.ExecOpts, p *prog.Prog, flags ProgTypes, stat Stat) *ipc.ProgInfo {
 	info := proc.executeRaw(execOpts, p, stat)
 	calls, extra := proc.fuzzer.checkNewSignal(p, info)
-	for _, callIndex := range calls {
+	for i, callIndex := range calls {
+		if i < prog.NOfCalls {
+			continue
+		}
 		proc.enqueueCallTriage(p, flags, callIndex, info.Calls[callIndex])
 	}
 	if extra {
@@ -347,3 +368,41 @@ func (proc *Proc) logProgram(opts *ipc.ExecOpts, p *prog.Prog) {
 		log.Fatalf("unknown output type: %v", proc.fuzzer.outputType)
 	}
 }
+
+func (proc *Proc) checkMutatingQueueLoop() {
+	for {
+		a := &rpctype.GetQueueLenArgs{
+			Flag: courier.Mutating,
+		}
+		r := &rpctype.GetQueueLenRes{}
+		if err := proc.fuzzer.manager.Call("Manager.GetQueueLen", a, r); err != nil {
+			log.Fatalf("checkArgsQueueLoop: failed to connect to manager: %v ", err)
+		}
+		if r.Length > 0 {
+			pq := &rpctype.ProgQueue{}
+			if err := proc.fuzzer.manager.Call("Manager.RetrieveArgsQueue", pq, pq); err != nil {
+				log.Fatalf("failed to connect to manager: %v ", err)
+			}
+			log.Logf(0, "New Arg Aviable: %s\n", pq.Prog)
+			p, err := proc.fuzzer.target.Deserialize(pq.Prog, prog.NonStrict)
+			if err != nil {
+				log.Fatalf("checkArgsQueueLoop: failed to parse program from manager: %v", err)
+			}
+			//sig := hash.Hash(pq.Prog)
+			//sign := pq.Prog.Signal.Deserialize()
+			//fuzzer.addInputToCorpus(p, sign, sig)
+			flags := ProgNormal
+			prog.NOfCalls = len(p.Calls)
+			prog.PocProg = string(pq.Prog)
+			if strings.Compare(string(pq.Prog), string(p.Serialize())) != 0 {
+				prog.PocProg = string(p.Serialize())
+				log.Logf(0, "Prog is not minimized\n")
+			}
+			proc.fuzzer.workQueue.enqueue(&WorkGrow{
+				p:     p,
+				flags: flags,
+			})
+		}
+		time.Sleep(10 * time.Second)
+	}
+}
diff --git a/syz-fuzzer/workqueue.go b/syz-fuzzer/workqueue.go
index 62648336..e31b664a 100644
--- a/syz-fuzzer/workqueue.go
+++ b/syz-fuzzer/workqueue.go
@@ -5,6 +5,7 @@ package main
 
 import (
 	"sync"
+	"time"
 
 	"github.com/google/syzkaller/pkg/ipc"
 	"github.com/google/syzkaller/prog"
@@ -20,6 +21,7 @@ type WorkQueue struct {
 	candidate       []*WorkCandidate
 	triage          []*WorkTriage
 	smash           []*WorkSmash
+	grow            []*WorkGrow
 
 	procs          int
 	needCandidates chan struct{}
@@ -61,6 +63,11 @@ type WorkSmash struct {
 	call int
 }
 
+type WorkGrow struct {
+	p     *prog.Prog
+	flags ProgTypes
+}
+
 func newWorkQueue(procs int, needCandidates chan struct{}) *WorkQueue {
 	return &WorkQueue{
 		procs:          procs,
@@ -71,6 +78,7 @@ func newWorkQueue(procs int, needCandidates chan struct{}) *WorkQueue {
 func (wq *WorkQueue) enqueue(item interface{}) {
 	wq.mu.Lock()
 	defer wq.mu.Unlock()
+	lastEnqueue = time.Now()
 	switch item := item.(type) {
 	case *WorkTriage:
 		if item.flags&ProgCandidate != 0 {
@@ -82,6 +90,8 @@ func (wq *WorkQueue) enqueue(item interface{}) {
 		wq.candidate = append(wq.candidate, item)
 	case *WorkSmash:
 		wq.smash = append(wq.smash, item)
+	case *WorkGrow:
+		wq.grow = append(wq.grow, item)
 	default:
 		panic("unknown work type")
 	}
@@ -89,7 +99,7 @@ func (wq *WorkQueue) enqueue(item interface{}) {
 
 func (wq *WorkQueue) dequeue() (item interface{}) {
 	wq.mu.RLock()
-	if len(wq.triageCandidate)+len(wq.candidate)+len(wq.triage)+len(wq.smash) == 0 {
+	if len(wq.triageCandidate)+len(wq.candidate)+len(wq.triage)+len(wq.smash)+len(wq.grow) == 0 {
 		wq.mu.RUnlock()
 		return nil
 	}
@@ -113,6 +123,10 @@ func (wq *WorkQueue) dequeue() (item interface{}) {
 		last := len(wq.smash) - 1
 		item = wq.smash[last]
 		wq.smash = wq.smash[:last]
+	} else if len(wq.grow) != 0 {
+		last := len(wq.grow) - 1
+		item = wq.grow[last]
+		wq.grow = wq.grow[:last]
 	}
 	wq.mu.Unlock()
 	if wantCandidates {
diff --git a/syz-manager/manager.go b/syz-manager/manager.go
index f92b5172..05005b74 100644
--- a/syz-manager/manager.go
+++ b/syz-manager/manager.go
@@ -16,6 +16,7 @@ import (
 	"sync"
 	"sync/atomic"
 	"time"
+	"strings"
 
 	"github.com/google/syzkaller/dashboard/dashapi"
 	"github.com/google/syzkaller/pkg/cover"
@@ -264,6 +265,11 @@ func RunManager(cfg *mgrconfig.Config, target *prog.Target, sysTarget *targets.T
 		<-vm.Shutdown
 		return
 	}
+	log.Logf(0, "ParseCustomizedTestcase begin\n")
+	err = ParseCustomizedTestcase(cfg.Testcase)
+	if err != nil {
+		log.Logf(0, "ParseCustomizedTestcase failed: %v\n", err)
+	}
 	mgr.vmLoop()
 }
 
@@ -414,6 +420,10 @@ func (mgr *Manager) vmLoop() {
 				}
 			} else {
 				mgr.saveRepro(res.res, res.stats, res.hub)
+				log.Logf(0, "SaveRepro %s", res.report0.Title)
+				if strings.Contains(res.report0.Title, "slab-out-of-bounds Write") {
+					shutdown = nil
+				}
 			}
 		case <-shutdown:
 			log.Logf(1, "loop: shutting down...")
diff --git a/syz-manager/rpc.go b/syz-manager/rpc.go
index e4875c20..57a6fc92 100644
--- a/syz-manager/rpc.go
+++ b/syz-manager/rpc.go
@@ -7,6 +7,7 @@ import (
 	"net"
 	"sync"
 
+	"github.com/google/syzkaller/courier"
 	"github.com/google/syzkaller/pkg/cover"
 	"github.com/google/syzkaller/pkg/log"
 	"github.com/google/syzkaller/pkg/rpctype"
@@ -182,3 +183,28 @@ func (serv *RPCServer) Poll(a *rpctype.PollArgs, r *rpctype.PollRes) error {
 		a.Name, len(r.Candidates), len(r.NewInputs), len(r.MaxSignal.Elems))
 	return nil
 }
+
+func (serv *RPCServer) GetQueueLen(a *rpctype.GetQueueLenArgs, r *rpctype.GetQueueLenRes) error {
+	switch a.Flag {
+	case courier.Mutating:
+		r.Length = len(courier.MutateArgsQueue)
+		break
+	case courier.Commands:
+		r.Length = len(courier.CommandsQueue)
+		break
+	case courier.S2E:
+		r.Length = len(courier.S2EArgsQueue)
+	}
+	return nil
+}
+
+func (serv *RPCServer) RetrieveArgsQueue(a *rpctype.ProgQueue, pq *rpctype.ProgQueue) error {
+	courier.Mutex.Lock()
+	p := courier.RetrieveFirstArg(courier.Mutating)
+	if p != nil {
+		pq.Prog = p.([]byte)
+	}
+	courier.Mutex.Unlock()
+	log.Logf(0, "Retrive %s\n", pq.Prog)
+	return nil
+}
diff --git a/syz-manager/utilities.go b/syz-manager/utilities.go
new file mode 100644
index 00000000..e48902ad
--- /dev/null
+++ b/syz-manager/utilities.go
@@ -0,0 +1,54 @@
+package main
+
+import (
+	"bytes"
+	"io/ioutil"
+	_ "net/http/pprof"
+	"os"
+
+	"github.com/google/syzkaller/courier"
+	"github.com/google/syzkaller/pkg/log"
+)
+
+//Read and parse testcase, send it to fuzzer
+func ParseCustomizedTestcase(path string) error {
+	info, err := os.Stat(path)
+	if !os.IsNotExist(err) {
+		if !info.IsDir() {
+			fileCache, err := os.Open(path)
+			if err != nil {
+				return err
+			}
+			defer fileCache.Close()
+			testcase_raw, err := ioutil.ReadFile(path)
+			if err != nil {
+				return err
+			}
+			testcase := removeComments(testcase_raw)
+			log.Logf(0, "testcase: %s\n", testcase)
+			appendTestcase(testcase)
+			return nil
+		}
+	}
+	return err
+}
+
+func appendTestcase(testcase []byte) {
+	courier.AppendMutatingQueue(testcase)
+}
+
+func removeComments(text []byte) []byte {
+	var res []byte
+	start := 0
+	lines := bytes.SplitAfter(text, []byte("\n"))
+	for i, line := range lines {
+		if line[0] != '#' {
+			start = i
+			break
+		}
+	}
+	for i := start; i < len(lines); i++ {
+		res = append(res, lines[i]...)
+	}
+	return res
+}
